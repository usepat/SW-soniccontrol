{% import "schema_templates.j2" as schema_templates %}

{# 
  Expected variables:
    - pure_command_contracts: List[CommandContract]
    - error_messages: List[CommandContract]
    - notification_messages: List[CommandContract]
    - custom_enums: List[Type[Enum]]

 Expected globals:
    - protocol_constants: Dict[str, Any]
#}

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>UsePAT API Documentation</title>
</head>
<body>
    <h1>UsePAT API Documentation</h1>

    <h2>Introduction</h2>
        <h3>How this API is structured</h3>
            Our Application Programming Interface (API) is designed to be a Remote Procedure Protocol (RPC).  
            That means that we define a set of functions (called commands in this documentation) that our devices can execute.
            Those commands, can be invoked by sending a command call over a request.
            As response the device will then return an appropriate answer object. 
            Such an answer object consists of single fields, that have a type, a name and a value.
            If the device fails executing the command, it will return an error as answer.

            The device is also able to produce logs and notification messages and send them directly to the remote controller. 
            However Logs and notification messages are not sent, when a master-slave-based protocol like MODBUS is used. 

            The API can be used with various underlying protocols. 
            There exists a text-based human-readable protocol that is used together with our in-house Software Sonic Control. 
            The only other protocol supported (so far) is MODBUS-RTU.

        <h3>MODBUS API</h3>
            MODBUS is a protocol that defines how a master client reads and writes memory buffers on a slave server.

            We use a "mailbox" system to implement our RPC protocol. A mailbox is a memory section to that can be written or read. 
            We define a command call mailbox, to that the command call has to be written and an answer mailbox, in that the device will put the answer. 

            TODO: should we use a execute_command flag, for command call mailbox? 
            TODO: describe pending flag, etc. for answer.
            TODO: what about a length field in answer mailbox?

            Therefore we support only the MODBUS functions write multiple holding registers (0x10) and read input registers (0x04). 
            And we only allow to read and write from the mailboxes. Where the answer mailbox is read only.

        <h3>Text-based API</h3>

    <h2>Types</h2>
        The primitive types used by the API are bool, uint8, uint16, uint32, int16, float. 
        Complex types used are strings, enums and structs for Version and Timestamp, which are explained here in more detail.

        <h4>Version</h4>
            Version consists of the member variables major_version, minor_version and patch_version.  
            It follows the conventional versioning schema.

        <h4>Timestamp</h4>
            The timestamp consists of the members variables: hour, minute, seconds, day, month and year.

        <h4>Enums</h4>
            {% for enum_class in enum_classes %}
                {{ schema_templates.enum_class_entry(enum_class) }}
            {% endfor %}

    <h2>Commands</h2>
        {% for command_contract in pure_command_contracts | sort(attribute="code") %} 
            {# pure_command_contracts should only contain command contracts that are not notifications or errors #}
            {{ schema_templates.command_contract_entry(command_contract )}}
        {% endfor %}

    <h2>Errors</h2>
        {% for error_message in error_messages | sort(attribute="code") %}
            {{ schema_templates.command_contract_entry(error_message )}}
        {% endfor %}

    <h2>Notifications</h2>
        {% for notification in notification_messages | sort(attribute="code") %}
            {{ schema_templates.command_contract_entry(notification )}}
        {% endfor %}
</body>
</html>
