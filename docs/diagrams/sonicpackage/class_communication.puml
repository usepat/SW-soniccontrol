@startuml class_communication

set separator . 
top to bottom direction

class "ConnectionFactory" as sonicpackage.communication.connection_factory.ConnectionFactory {
  {abstract}open_connection() -> Tuple[asyncio.StreamReader, asyncio.StreamWriter]
}

class "CLIConnectionFactory" as sonicpackage.communication.connection_factory.CLIConnectionFactory {
  open_connection() -> Tuple[asyncio.StreamReader, asyncio.StreamWriter]
}

class "SerialConnectionFactory" as sonicpackage.communication.connection_factory.SerialConnectionFactory {
  open_connection() -> Tuple[asyncio.StreamReader, asyncio.StreamWriter]
}

class "EventManager" as sonicpackage.events.EventManager {
  emit(event: Event) -> None
  subscribe(event_type: str, listener: Callable[[Event], None]) -> None
  subscribe_property_listener(property_name: str, listener: Callable[[PropertyChangeEvent], None]) -> None
}

class "Communicator" as sonicpackage.communication.communicator.Communicator {
  DISCONNECTED_EVENT : str
  connection_opened
  handshake_result
  protocol
  {abstract}close_communication() -> None
  {abstract}open_communication(connection_factory: ConnectionFactory)
  {abstract}read_message() -> str
  {abstract}send_and_wait_for_answer(message: Sendable) -> None
}

class "LegacySerialCommunicator" as sonicpackage.communication.serial_communicator.LegacySerialCommunicator {
  BAUDRATE : int
  connection_closed
  connection_opened
  handshake_result
  protocol
  close_communication() -> None
  open_communication(connection_factory: ConnectionFactory) -> None
  read_long_message(response_time: float, reading_time: float) -> List[str]
  read_message() -> str
  send_and_wait_for_answer(command: Command) -> None
}

class "PackageFetcher" as sonicpackage.communication.package_fetcher.PackageFetcher {
  is_running
  get_answer_of_package(package_id: int) -> str
  pop_message() -> str
  run() -> None
  stop() -> None
}

class "SerialCommunicator" as sonicpackage.communication.serial_communicator.SerialCommunicator {
  BAUDRATE : int
  connection_opened
  handshake_result
  protocol
  close_communication() -> None
  open_communication(connection_factory: ConnectionFactory, loop) -> None
  read_message() -> str
  send_and_wait_for_answer(command: Command) -> None
}

class "CommunicationProtocol" as sonicpackage.communication.sonicprotocol.CommunicationProtocol {
  end_symbol
  major_version
  max_bytes
  start_symbol
  {abstract}parse_request(request: str, request_id: int) -> Any
  {abstract}parse_response(response: str) -> Any
  {abstract}prot_type() -> ProtocolType
}

class "LegacySonicProtocol" as sonicpackage.communication.sonicprotocol.LegacySonicProtocol {
  end_symbol
  major_version
  max_bytes
  start_symbol
  parse_request(request: str, request_id: int) -> Any
  parse_response(response: str) -> str
  {abstract}prot_type() -> ProtocolType
}

class "SonicProtocol" as sonicpackage.communication.sonicprotocol.SonicProtocol {
  LOG_PREFIX : str
  end_symbol
  major_version
  max_bytes
  start_symbol
  parse_request(request: str, request_id: int) -> str
  parse_response(response: str) -> tuple[int, str]
  {abstract}prot_type() -> ProtocolType
}

class "PackageParser" as sonicpackage.communication.package_parser.PackageParser {
  end_symbol : str
  max_bytes : int
  start_symbol : str
  parse_package(data: str) -> Package
  write_package(package: Package) -> str
}

class "Package" as sonicpackage.communication.package_parser.Package {
  content : str
  destination : str
  identifier : int
  length
  source : str
}

class "CommunicatorBuilder" as sonicpackage.communication.communicator_builder.CommunicatorBuilder {
  build(connection_factory: ConnectionFactory, logger: logging.Logger) -> tuple[Communicator, Union[CommandSet, CommandSetLegacy]]
}

sonicpackage.communication.connection_factory.CLIConnectionFactory -d-|> sonicpackage.communication.connection_factory.ConnectionFactory
sonicpackage.communication.connection_factory.SerialConnectionFactory -d-|> sonicpackage.communication.connection_factory.ConnectionFactory
sonicpackage.communication.serial_communicator.LegacySerialCommunicator -d-|> sonicpackage.communication.communicator.Communicator
sonicpackage.communication.serial_communicator.SerialCommunicator -d-|> sonicpackage.communication.communicator.Communicator
sonicpackage.communication.sonicprotocol.LegacySonicProtocol -d-|> sonicpackage.communication.sonicprotocol.CommunicationProtocol
sonicpackage.communication.sonicprotocol.SonicProtocol -d-|> sonicpackage.communication.sonicprotocol.CommunicationProtocol
sonicpackage.communication.communicator.Communicator -d-|> sonicpackage.events.EventManager
sonicpackage.communication.serial_communicator.SerialCommunicator *-u- sonicpackage.communication.package_fetcher.PackageFetcher : _package_fetcher
sonicpackage.communication.serial_communicator.LegacySerialCommunicator *-u- sonicpackage.communication.sonicprotocol.LegacySonicProtocol : _protocol
sonicpackage.communication.serial_communicator.SerialCommunicator *-u- sonicpackage.communication.sonicprotocol.SonicProtocol : _protocol
sonicpackage.communication.package_fetcher.PackageFetcher o-u- sonicpackage.communication.sonicprotocol.SonicProtocol : _protocol
sonicpackage.communication.communicator.Communicator *-l- sonicpackage.communication.connection_factory.ConnectionFactory
sonicpackage.communication.communicator.Communicator <.l. sonicpackage.communication.communicator_builder.CommunicatorBuilder
sonicpackage.communication.connection_factory.ConnectionFactory <.[hidden]. sonicpackage.communication.communicator_builder.CommunicatorBuilder
sonicpackage.communication.sonicprotocol.SonicProtocol .u.> sonicpackage.communication.package_parser.PackageParser

@enduml